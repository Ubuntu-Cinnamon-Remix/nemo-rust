// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../gir-files
// DO NOT EDIT

use glib::object::IsA;
use glib::translate::*;
use std::fmt;

glib::wrapper! {
    #[doc(alias = "NemoFileInfo")]
    pub struct FileInfo(Interface<ffi::NemoFileInfo, ffi::NemoFileInfoInterface>);

    match fn {
        type_ => || ffi::nemo_file_info_get_type(),
    }
}

impl FileInfo {
        pub const NONE: Option<&'static FileInfo> = None;
    

    #[doc(alias = "nemo_file_info_create")]
    pub fn create(location: &impl IsA<gio::File>) -> Option<FileInfo> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nemo_file_info_create(location.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nemo_file_info_create_for_uri")]
    pub fn create_for_uri(uri: &str) -> Option<FileInfo> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nemo_file_info_create_for_uri(uri.to_glib_none().0))
        }
    }

    #[doc(alias = "nemo_file_info_list_copy")]
    pub fn list_copy(files: &[FileInfo]) -> Vec<FileInfo> {
        assert_initialized_main_thread!();
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nemo_file_info_list_copy(files.to_glib_none().0))
        }
    }

    #[doc(alias = "nemo_file_info_list_free")]
    pub fn list_free(files: &[FileInfo]) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::nemo_file_info_list_free(files.to_glib_none().0);
        }
    }

    #[doc(alias = "nemo_file_info_lookup")]
    pub fn lookup(location: &impl IsA<gio::File>) -> Option<FileInfo> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nemo_file_info_lookup(location.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "nemo_file_info_lookup_for_uri")]
    pub fn lookup_for_uri(uri: &str) -> Option<FileInfo> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::nemo_file_info_lookup_for_uri(uri.to_glib_none().0))
        }
    }
}

pub trait FileInfoExt: 'static {
    #[doc(alias = "nemo_file_info_add_emblem")]
    fn add_emblem(&self, emblem_name: &str);

    #[doc(alias = "nemo_file_info_add_string_attribute")]
    fn add_string_attribute(&self, attribute_name: &str, value: &str);

    #[doc(alias = "nemo_file_info_can_write")]
    fn can_write(&self) -> bool;

    #[doc(alias = "nemo_file_info_get_activation_uri")]
    #[doc(alias = "get_activation_uri")]
    fn activation_uri(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_file_type")]
    #[doc(alias = "get_file_type")]
    fn file_type(&self) -> gio::FileType;

    #[doc(alias = "nemo_file_info_get_location")]
    #[doc(alias = "get_location")]
    fn location(&self) -> Option<gio::File>;

    #[doc(alias = "nemo_file_info_get_mime_type")]
    #[doc(alias = "get_mime_type")]
    fn mime_type(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_mount")]
    #[doc(alias = "get_mount")]
    fn mount(&self) -> Option<gio::Mount>;

    #[doc(alias = "nemo_file_info_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_parent_info")]
    #[doc(alias = "get_parent_info")]
#[must_use]
    fn parent_info(&self) -> Option<FileInfo>;

    #[doc(alias = "nemo_file_info_get_parent_location")]
    #[doc(alias = "get_parent_location")]
    fn parent_location(&self) -> Option<gio::File>;

    #[doc(alias = "nemo_file_info_get_parent_uri")]
    #[doc(alias = "get_parent_uri")]
    fn parent_uri(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_string_attribute")]
    #[doc(alias = "get_string_attribute")]
    fn string_attribute(&self, attribute_name: &str) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_uri")]
    #[doc(alias = "get_uri")]
    fn uri(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_get_uri_scheme")]
    #[doc(alias = "get_uri_scheme")]
    fn uri_scheme(&self) -> Option<glib::GString>;

    #[doc(alias = "nemo_file_info_invalidate_extension_info")]
    fn invalidate_extension_info(&self);

    #[doc(alias = "nemo_file_info_is_directory")]
    fn is_directory(&self) -> bool;

    #[doc(alias = "nemo_file_info_is_gone")]
    fn is_gone(&self) -> bool;

    #[doc(alias = "nemo_file_info_is_mime_type")]
    fn is_mime_type(&self, mime_type: &str) -> bool;
}

impl<O: IsA<FileInfo>> FileInfoExt for O {
    fn add_emblem(&self, emblem_name: &str) {
        unsafe {
            ffi::nemo_file_info_add_emblem(self.as_ref().to_glib_none().0, emblem_name.to_glib_none().0);
        }
    }

    fn add_string_attribute(&self, attribute_name: &str, value: &str) {
        unsafe {
            ffi::nemo_file_info_add_string_attribute(self.as_ref().to_glib_none().0, attribute_name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    fn can_write(&self) -> bool {
        unsafe {
            from_glib(ffi::nemo_file_info_can_write(self.as_ref().to_glib_none().0))
        }
    }

    fn activation_uri(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_activation_uri(self.as_ref().to_glib_none().0))
        }
    }

    fn file_type(&self) -> gio::FileType {
        unsafe {
            from_glib(ffi::nemo_file_info_get_file_type(self.as_ref().to_glib_none().0))
        }
    }

    fn location(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_location(self.as_ref().to_glib_none().0))
        }
    }

    fn mime_type(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_mime_type(self.as_ref().to_glib_none().0))
        }
    }

    fn mount(&self) -> Option<gio::Mount> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_mount(self.as_ref().to_glib_none().0))
        }
    }

    fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_name(self.as_ref().to_glib_none().0))
        }
    }

    fn parent_info(&self) -> Option<FileInfo> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_parent_info(self.as_ref().to_glib_none().0))
        }
    }

    fn parent_location(&self) -> Option<gio::File> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_parent_location(self.as_ref().to_glib_none().0))
        }
    }

    fn parent_uri(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_parent_uri(self.as_ref().to_glib_none().0))
        }
    }

    fn string_attribute(&self, attribute_name: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_string_attribute(self.as_ref().to_glib_none().0, attribute_name.to_glib_none().0))
        }
    }

    fn uri(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_uri(self.as_ref().to_glib_none().0))
        }
    }

    fn uri_scheme(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nemo_file_info_get_uri_scheme(self.as_ref().to_glib_none().0))
        }
    }

    fn invalidate_extension_info(&self) {
        unsafe {
            ffi::nemo_file_info_invalidate_extension_info(self.as_ref().to_glib_none().0);
        }
    }

    fn is_directory(&self) -> bool {
        unsafe {
            from_glib(ffi::nemo_file_info_is_directory(self.as_ref().to_glib_none().0))
        }
    }

    fn is_gone(&self) -> bool {
        unsafe {
            from_glib(ffi::nemo_file_info_is_gone(self.as_ref().to_glib_none().0))
        }
    }

    fn is_mime_type(&self, mime_type: &str) -> bool {
        unsafe {
            from_glib(ffi::nemo_file_info_is_mime_type(self.as_ref().to_glib_none().0, mime_type.to_glib_none().0))
        }
    }
}

impl fmt::Display for FileInfo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("FileInfo")
    }
}
